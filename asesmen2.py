# -*- coding: utf-8 -*-
"""Asesmen2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1h-CwhfLn_C6Kzf_eswq6Tj4i780mvPd-
"""

import torch
import torch.nn.functional as F
from torch.utils.data import random_split, DataLoader
from torch.utils.data import Dataset
import pandas as pd
from sklearn.preprocessing import LabelEncoder
import torch.nn as nn
import torch.optim as optim

import kagglehub

# Download latest version
path = kagglehub.dataset_download("arshid/iris-flower-dataset")

print("Path to dataset files:", path)

"""# ***Model.py***"""

class IrisFlowerClassifier(nn.Module):

	def __init__(self, input_size=4, hidden_size = 16, num_classes=3):

		super(IrisFlowerClassifier,self).__init__()
		self.fc1 = nn.Linear(input_size, hidden_size)
		self.fc2 = nn.Linear(hidden_size, num_classes)

	def forward(self, x):
		x = F.relu(self.fc1(x))
		x = self.fc2(x)

		return x

"""# **Dataset.py**

"""

class IrisDataset(Dataset):
    def __init__(self, csv_file_path):
        self.data = pd.read_csv(csv_file_path)
        self.le = LabelEncoder()


        self.data['label'] = self.le.fit_transform(self.data['species'])

        features = ['sepal_length', 'sepal_width', 'petal_length', 'petal_width']
        for feature in features:
            self.data[feature] = (
                self.data[feature] - self.data[feature].min()
            ) / (self.data[feature].max() - self.data[feature].min())

    def __len__(self):
        return len(self.data)

    def __getitem__(self, idx):
        x = torch.tensor([
            self.data.iloc[idx]['sepal_length'],
            self.data.iloc[idx]['sepal_width'],
            self.data.iloc[idx]['petal_length'],
            self.data.iloc[idx]['petal_width']
        ], dtype=torch.float32)

        y = torch.tensor(self.data.iloc[idx]['label'], dtype=torch.long)

        return x, y

csv_path = "/kaggle/IRIS.csv"
dataset = IrisDataset(csv_path)



print(len(dataset))             # Jumlah data
print(dataset[0])               # Contoh (fitur, label)
print(dataset.le.classes_)      # Label asli: ['setosa', 'versicolor', 'virginica']

"""# **Train.py**"""

import torch
import torch.nn.functional as F
from torch.utils.data import random_split, DataLoader


# Menggunakan IrisDataset yang sudah kamu buat
import pandas as pd
from torch.utils.data import Dataset
from sklearn.preprocessing import LabelEncoder

class IrisDataset(Dataset):
    def __init__(self, csv_file_path):
        self.data = pd.read_csv(csv_file_path)
        self.le = LabelEncoder()
        self.data['label'] = self.le.fit_transform(self.data['species'])
        features = ['sepal_length', 'sepal_width', 'petal_length', 'petal_width']
        for feature in features:
            self.data[feature] = (
                self.data[feature] - self.data[feature].min()
            ) / (self.data[feature].max() - self.data[feature].min())

    def __len__(self):
        return len(self.data)

    def __getitem__(self, idx):
        x = torch.tensor([
            self.data.iloc[idx]['sepal_length'],
            self.data.iloc[idx]['sepal_width'],
            self.data.iloc[idx]['petal_length'],
            self.data.iloc[idx]['petal_width']
        ], dtype=torch.float32)

        y = torch.tensor(self.data.iloc[idx]['label'], dtype=torch.long)

        return x, y

# Load dataset
csv_path = "/kaggle/input/iris-flower-dataset/IRIS.csv"
dataset = IrisDataset(csv_path)

# Split train/test
train_set, test_set = random_split(dataset, [120, 30])  # total = 150

# Loaders
train_loader = DataLoader(train_set, batch_size=16, shuffle=True)
test_loader = DataLoader(test_set, batch_size=16)

# Model & optimizer
model = IrisFlowerClassifier(input_size=4, hidden_size=16, num_classes=3)
optimizer = torch.optim.Adam(model.parameters(), lr=0.01)

# Training loop
for epoch in range(50):
    model.train()
    total_loss = 0
    for x, y in train_loader:
        logits = model(x)
        loss = F.cross_entropy(logits, y)
        optimizer.zero_grad()
        loss.backward()
        optimizer.step()
        total_loss += loss.item()
    print(f"Epoch {epoch+1}, Loss: {total_loss:.4f}")

# Save model
torch.save(model.state_dict(), 'iris_model.pth')
print("Model saved")

# Evaluasi akurasi
model.eval()
correct = 0
total = 0

with torch.no_grad():
    for x, y in test_loader:
        preds = model(x).argmax(dim=1)
        correct += (preds == y).sum().item()
        total += y.size(0)

print(f"Accuracy on test set: {100 * correct / total:.2f}%")

"""# **Predict.py**"""

model = IrisFlowerClassifier(input_size=4, hidden_size=16, num_classes=3)
model.load_state_dict(torch.load('iris_model.pth'))
model.eval()  # Set model ke evaluasi mode

def predict_iris(features):
    with torch.no_grad():
        features = torch.tensor(features, dtype=torch.float32).unsqueeze(0)
        logits = model(features)
        predicted_class = logits.argmax(dim=1).item()
        return predicted_class


features = [5.1, 3.5, 1.4, 0.2]  # Sepal length, sepal width, petal length, petal width
predicted_class = predict_iris(features)

print(f"Predicted class (encoded): {predicted_class}")
print(f"Predicted class (actual species): {dataset.le.classes_[predicted_class]}")

torch.save(model.state_dict(), 'model.pth')
print("Model saved to model.pth")

"""#***iris_logreg.py***"""

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder, MinMaxScaler
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix

# Load dataset
csv_path = "/kaggle/input/iris-flower-dataset/IRIS.csv"
df = pd.read_csv(csv_path)

# Label encoding
le = LabelEncoder()
df['label'] = le.fit_transform(df['species'])

# Fitur dan label
X = df[['sepal_length', 'sepal_width', 'petal_length', 'petal_width']]
y = df['label']

# Normalisasi fitur
scaler = MinMaxScaler()
X_scaled = scaler.fit_transform(X)

# Train-test split
X_train, X_test, y_train, y_test = train_test_split(
    X_scaled, y, test_size=0.2, random_state=42
)

# Logistic Regression
model = LogisticRegression(max_iter=200)
model.fit(X_train, y_train)

# Prediksi
y_pred = model.predict(X_test)

# Evaluasi
accuracy = accuracy_score(y_test, y_pred)
print(f"Akurasi Logistic Regression: {accuracy * 100:.2f}%")

# Laporan klasifikasi
print("\nClassification Report:")
print(classification_report(y_test, y_pred, target_names=le.classes_))

# Confusion Matrix
print("\nConfusion Matrix:")
print(confusion_matrix(y_test, y_pred))